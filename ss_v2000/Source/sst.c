#include "sst.h"#include "filectrl.h"//単独SSTstatic  ERRCODE NewSST( LPCTSTR lpszFile,LPSST lpSST  );static  VOID	DeleteSST( LPSST lpSST );static  VOID InitializeSST( LPSST lpSST );static  BOOL	GetNextElement( LPSST lpSST,LPSTR lpszKBuff,				LPSTR lpszYBuff,LPSTR lpszYLowBuff );				//データの並び替えstatic  VOID RandomizeSST( LPSST lpSST );static VOID RandomizeSSTA( LPSSTA lpSSTA );static  INT GetRandomSST( LPSSTA lpSSTA );VOID	DeleteSSTA( LPSSTA lpSSTA ){	INT i;	for( i=0;i<lpSSTA->dwNumOfSST;i++ ){		DeleteSST( &(lpSSTA->lpSST[i]) );	}		if( lpSSTA->lpSST )		GlobalFree( lpSSTA->lpSST );		ZeroMemory( lpSSTA,sizeof( SSTA ));}VOID	DeleteSST( LPSST lpSST ){	if( lpSST->lpElement ){    	GlobalFree( lpSST->lpElement );	}	if( lpSST->lpszTitle ){		GlobalFree( lpSST->lpszTitle );	}	if( lpSST->lpszDesc ){		GlobalFree( lpSST->lpszDesc );	}	ZeroMemory( lpSST,sizeof( SST ) );	}ERRCODE NewSSTA( LPCTSTR lpszFile,LPSSTA lpSSTA  ){	ERRCODE err = ERR_NOTHING;	CHAR *tmp;	INT i,size,rs,z;	SSTA ssta;	CHAR *curF,*curT,*curD,*cur;		ZeroMemory( lpSSTA,sizeof( SSTA ));	ZeroMemory( &ssta,sizeof( SSTA ));			if( (err = ReadFileToMemory( lpszFile,&tmp ))!= ERR_NOTHING ){				return err;	}	size = GlobalSize( tmp );	for( i=0,rs=0;i<size;i++ ){		if( tmp[i]=='\r' ){			tmp[i]='\0';			tmp[i+1]='\0';			i++;			rs++;		}	}	//CHANGE 2000/12/29-- 正体不明のバグを回避//	if( rs == 0 || rs%3 != 0 ){//		GlobalFree( tmp );//		return ERR_FILEFORMAT;//	}	if( rs < 3 ){		GlobalFree( tmp );		return ERR_FILEFORMAT;	}	if( rs%3 != 0 )		rs--;	if( rs == 0 || rs%3 != 0 ){		GlobalFree( tmp );		return ERR_FILEFORMAT;	}//--2000/12/29	rs/=3;	cur = tmp;	ssta.dwNumOfSST = rs;	ssta.lpSST = (LPSST)GlobalAlloc( GPTR,sizeof(SST)*rs );	if( !ssta.lpSST ){		GlobalFree( tmp );		return ERR_MEMORY;	}		for( z=0;z<rs;z++ ){		curF = cur;		cur += lstrlen( curF )+2;//+2 is NULL+'\n' 		curT = cur;		cur += lstrlen( curT )+2;		curD = cur;		cur += lstrlen( curD )+2;				if( (err=NewSST( curF,&ssta.lpSST[z])) != ERR_NOTHING ){			DeleteSSTA( &ssta );			GlobalFree( tmp );			return err;		}				ssta.lpSST[z].lpszTitle = GlobalAlloc( GMEM_FIXED,lstrlen(curT)+1 ); //+1 isNULL		if( !ssta.lpSST[z].lpszTitle ){			DeleteSSTA( &ssta );			GlobalFree( tmp );			return ERR_MEMORY;		}		lstrcpy( ssta.lpSST[z].lpszTitle,curT );				ssta.lpSST[z].lpszDesc = GlobalAlloc( GMEM_FIXED,lstrlen(curD)+1 ); //+1 isNULL		if( !ssta.lpSST[z].lpszDesc ){			DeleteSSTA( &ssta );			GlobalFree( tmp );			return ERR_MEMORY;		}			lstrcpy( ssta.lpSST[z].lpszDesc,curD );				ssta.dwTotalOfElement += ssta.lpSST[z].dwNumOfElement;	}		GlobalFree( tmp );		//Copy...	lpSSTA->dwNumOfSST = ssta.dwNumOfSST;	lpSSTA->dwTotalOfElement = ssta.dwTotalOfElement;	lpSSTA->lpSST = ssta.lpSST;			return ERR_NOTHING;	}ERRCODE NewSST( LPCTSTR lpszFile,LPSST lpSST  ){    DWORD i,s,z,c,rs;    CHAR  *data;    ERRCODE err = ERR_NOTHING;    SST sst;				ZeroMemory( lpSST,sizeof( SST ));				if( (err = ReadFileToMemory( lpszFile,&data ))!= ERR_NOTHING ){				return err;		}		s = GlobalSize( data );   		for( rs=0,i=0;i<s;i++ ){         	if( data[i]=='\r' )            	rs++;        }//CHANGE 2000/12/29 正体不明のバグを回避。何故か改行の数が奇数になることがある//        if( rs==0 || rs%2 !=0 ){//         	GlobalFree( data );//            return ERR_FILEFORMAT;//        }      if( rs==0 ){         	GlobalFree( data );            return ERR_FILEFORMAT; 	} 	 	if( rs%2 != 0 ) 		rs -- ; 	 	if( rs==0 || rs%2 !=0 ){         	GlobalFree( data );            return ERR_FILEFORMAT; 	}///END OF CHANGE 2000/12/29        rs/=2;        if( (sst.lpElement = (LPSSTELEMENT)GlobalAlloc(  GMEM_FIXED,sizeof(SSTELEMENT)*rs ))==NULL){        	GlobalFree( data );            return ERR_MEMORY;        }        sst.dwNumOfElement = rs;        for( z=0,c=0;z<rs;z++ ){    	for( i=0;i<256;i++,c++ ){           sst.lpElement[z].cKanji[i] = data[c];           if( data[c] == '\r' ){           		sst.lpElement[z].cKanji[i] = '\0';                c+=2;                break;           }                }        if( i>=256 ){         	GlobalFree( data );         	GlobalFree( sst.lpElement );            return ERR_FILEFORMAT;        }        for( i=0;i<256;i++,c++ ){           sst.lpElement[z].cYomi[i] = data[c];           if( data[c] == '\r' ){           		sst.lpElement[z].cYomi[i] = '\0';                c+=2;                break;           }        }        if( i>=256 ){         	GlobalFree( data );         	GlobalFree( sst.lpElement );            return ERR_FILEFORMAT;        }	//デフォルトは、シーケンシャルサーチ        sst.lpElement[z].dwIndex= z;        }	GlobalFree( data );		//Copy...	lpSST->dwNumOfElement = sst.dwNumOfElement;	lpSST->lpElement = sst.lpElement;			return ERR_NOTHING;}DWORD InitializeSSTA( LPSSTA lpSSTA,INT iIndex,DWORD dwMax ){	INT i;	DWORD theMax;		if( iIndex == -1 ){		theMax = min( lpSSTA->dwTotalOfElement,dwMax );		RandomizeSSTA( lpSSTA );	}	else{		theMax = min( lpSSTA->lpSST[iIndex].dwNumOfElement,dwMax );		RandomizeSST( &(lpSSTA->lpSST[iIndex]) );	}	lpSSTA->dwMax = theMax;	lpSSTA->iIndex = iIndex;	lpSSTA->iNext = 0;	for( i = 0;i<lpSSTA->dwNumOfSST;i++ )		InitializeSST( &(lpSSTA->lpSST[i]) );			return lpSSTA->dwMax;}VOID InitializeSST( LPSST lpSST ){	lpSST->iNext = 0;}//RET:FALSE データ終了 TRUE:データあり//漢字、読みバッファは呼び出し側で十分な量を確保することBOOL	GetNextElement( LPSST lpSST,LPSTR lpszKBuff,						LPSTR lpszYBuff,LPSTR lpszYLowBuff ){	DWORD index;	INT iNext = lpSST->iNext;		if( iNext == -1 )		return FALSE;   index = lpSST->lpElement[iNext].dwIndex;   lstrcpy( lpszKBuff,lpSST->lpElement[index].cKanji );   lstrcpy( lpszYBuff,lpSST->lpElement[index].cYomi );   lstrcpy( lpszYLowBuff,lpszYBuff );   CharLowerBuff( lpszYLowBuff,lstrlen( lpszYLowBuff ) );      lpSST->iNext ++;   if( lpSST->iNext >= lpSST->dwNumOfElement )   	lpSST->iNext = -1; //データ終了    return TRUE;}BOOL GetNextElementA( LPSSTA lpSSTA,		LPSTR lpszKBuff,LPSTR lpszYBuff,LPSTR lpszYLowBuff ){	INT i,itmp;	INT iIndex;		if( lpSSTA->iNext == -1 )		return FALSE;		iIndex = lpSSTA->iIndex;	if(  iIndex == -1 ){		itmp = GetRandomSST( lpSSTA );		if( !GetNextElement( &(lpSSTA->lpSST[itmp]),lpszKBuff,							lpszYBuff,lpszYLowBuff ) ){			for( i=(lpSSTA->dwNumOfSST)-1;i>=0;i-- ){				if(GetNextElement( &(lpSSTA->lpSST[i]),lpszKBuff,							lpszYBuff,lpszYLowBuff ))					break;			}			//change 2000/12/07			//if( i >= lpSSTA->dwNumOfSST )				 if( i < 0 )					return FALSE; //ないと思うんだが...							}	}	else{		if( !GetNextElement( &(lpSSTA->lpSST[iIndex]),lpszKBuff,							lpszYBuff,lpszYLowBuff ) )							return FALSE; //ないと思うんだが...								}		lpSSTA->iNext++;	if( lpSSTA->iNext >= lpSSTA->dwMax )   	lpSSTA->iNext = -1; //データ終了    	return TRUE;}INT GetRandomSST( LPSSTA lpSSTA ){	SYSTEMTIME st;	if( !lpSSTA->dwNumOfSST )		return 0;		GetSystemTime( &st );		return (INT)(st.wSecond%(lpSSTA->dwNumOfSST));}VOID RandomizeSSTA( LPSSTA lpSSTA ){	INT i;	for( i=0;i<lpSSTA->dwNumOfSST;i++ ){		RandomizeSST( &(lpSSTA->lpSST[i]) );	}}VOID RandomizeSST( LPSST lpSST ){#define N		lpSST->dwNumOfElement#define M		lpSST->lpElement	INT i=0,j=0,shifts0,shifts1,shifts2;	DWORD index0=0,index1=0,index2=0;	SYSTEMTIME st;		if( N <= 0 )		return;	for( i=0;i<N;i++ )    			M[i].bSetData = FALSE; //Clear FlagsGetSystemTime( &st );if( st.wMinute <= 0 )		st.wMinute = 1;	if( st.wSecond <= 0 )		st.wSecond = 1;	if( st.wMilliseconds <= 0 )		st.wMilliseconds = 1;	shifts0 = st.wMinute % 9;	shifts1 = st.wSecond % 9;	shifts2 = st.wMilliseconds % 9; 	index0 = st.wSecond;	index1 = st.wMinute;	index2 = st.wMilliseconds;	for( i=0;i<N;i++ ){		index0 += shifts0+i+j;		index1 += shifts1+i+j;		index2 +=shifts2+i+j;	index0 %= N;	index1 %= N;	index2 %= N;			if( M[index0].bSetData == FALSE ){			M[index0].bSetData = TRUE;			M[index0].dwIndex = i;		}		else if( M[index1].bSetData == FALSE ){			M[index1].bSetData = TRUE;			M[index1].dwIndex = i;		}		else if( M[index2].bSetData == FALSE ){			M[index2].bSetData = TRUE;			M[index2].dwIndex = i;		}		else if( index1%2 ){			for( j=(N-1);j>=0;j-- ){				if( M[j].bSetData == FALSE ){					M[j].bSetData = TRUE;					M[j].dwIndex = i;					break;				}			}		}		else{			for( j=0;j<N;j++ ){				if( M[j].bSetData == FALSE ){					M[j].bSetData = TRUE;					M[j].dwIndex = i;					break;				}			}		}				}#undef M#undef N}