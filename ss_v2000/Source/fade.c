#include "fade.h"#include "dibctrl.h"#include "filectrl.h"#define MAX_FADE	8//DIBファイルからフェード構造体を作成するERRCODE NewDIBFade( LPCTSTR lpszFile,					LPDIBFADE lpDIBFade,RGBQUAD* prgbBackGround   ){	 CHAR FAR* p;	 CHAR FAR* p2;	ERRCODE err;	BITMAPINFOHEADER info;	CHAR szFile[MAX_PATH];		ZeroMemory( lpDIBFade,sizeof( DIBFADE ) );		//DIBファイルの読み込み	err = OpenDIB( lpszFile,&lpDIBFade->hDIB );	if( err == ERR_FILEACCESS ){		if( FilePathToFileName( szFile,lpszFile,sizeof(szFile) ) )			err = OpenDIB( szFile,&lpDIBFade->hDIB );	}		if( err != ERR_NOTHING )		return err;		//情報の取得	info = *(LPBITMAPINFOHEADER)GlobalLock (lpDIBFade->hDIB);    	GlobalUnlock (lpDIBFade->hDIB);		 lpDIBFade->dwNumOfColors = info.biClrUsed;	 lpDIBFade->dwWidth = info.biWidth;	 lpDIBFade->dwHeight = info.biHeight;	 lpDIBFade->dwOffRGB = info.biSize;	 lpDIBFade->dwSizeRGB = info.biClrUsed * sizeof(RGBQUAD);		//オリジナルカラーテーブルの保存          if( lpDIBFade->dwSizeRGB > 0 ){          	lpDIBFade->pOrgRGB = (RGBQUAD FAR*)GlobalAlloc( GMEM_FIXED,lpDIBFade->dwSizeRGB );          	p2 = (CHAR FAR*)lpDIBFade->pOrgRGB;	   }	   else{	   	//カラーテーブルを持たないDIBはフェードインできない!	   	DeleteDIBFade( lpDIBFade );	   	return ERR_FILEFORMAT;	   }		p = (CHAR FAR*)GlobalLock( lpDIBFade->hDIB );		//保存して、	p+=lpDIBFade->dwOffRGB;;	CopyMemory( p2,p,lpDIBFade->dwSizeRGB ); 		GlobalUnlock( lpDIBFade->hDIB );		//背景色の指定。なければすでに黒に初期化されている	if( prgbBackGround ){		CopyMemory( &lpDIBFade->rgbBackGround,prgbBackGround,sizeof(RGBQUAD) );			}	return ERR_NOTHING;}VOID DeleteDIBFade( LPDIBFADE lpDIBFade ){	if( lpDIBFade->hDIB )		GlobalFree( lpDIBFade->hDIB );			if( lpDIBFade->pOrgRGB )		GlobalFree( lpDIBFade->pOrgRGB );	//構造体の初期化はこの関数が便利	ZeroMemory( lpDIBFade,sizeof( DIBFADE ));}VOID BeginDIBFade( LPDIBFADE lpDIBFade ){	CHAR FAR* p;	RGBQUAD FAR* pRGB;	INT i;	p = (CHAR FAR*)GlobalLock( lpDIBFade->hDIB );	p+=lpDIBFade->dwOffRGB;	pRGB = (RGBQUAD FAR*)p;	//指定色に変える	for( i=0;i<lpDIBFade->dwNumOfColors;i++ ){		pRGB[i].rgbRed = lpDIBFade->rgbBackGround.rgbRed;		pRGB[i].rgbGreen = lpDIBFade->rgbBackGround.rgbGreen;		pRGB[i].rgbBlue = lpDIBFade->rgbBackGround.rgbBlue;	}//	FillMemory( p,lpDIBFade->dwSizeRGB,lpDIBFade->byBGColor);	GlobalUnlock( lpDIBFade->hDIB );		lpDIBFade->iFadeBits = 0;	lpDIBFade->bIsFadeIn = TRUE;	lpDIBFade->bIsFadeOut = FALSE;	}FADESTATUS FadeDIBFade( LPDIBFADE lpDIBFade ){	register INT i;	WORD mask=0;	WORD now=0;	CHAR FAR* p;	RGBQUAD FAR* pRGB=NULL;	if( !lpDIBFade->bIsFadeIn && !lpDIBFade->bIsFadeOut )		return FADE_OUTEND;		p = (CHAR FAR*)GlobalLock( lpDIBFade->hDIB );	p+=lpDIBFade->dwOffRGB;	pRGB = (RGBQUAD FAR*)p;		for( i=0;i<lpDIBFade->dwNumOfColors;i++ ){		if( lpDIBFade->bIsFadeIn ){						mask = (WORD)lpDIBFade->rgbBackGround.rgbRed;			mask <<= MAX_FADE; //For use HIBYTE			now = (WORD)lpDIBFade->pOrgRGB[i].rgbRed;			now <<= 1+lpDIBFade->iFadeBits; //Fade IN				mask <<= 1+lpDIBFade->iFadeBits;			now |= mask;			pRGB[i].rgbRed = HIBYTE( now );						mask = (WORD)lpDIBFade->rgbBackGround.rgbGreen;			mask <<= MAX_FADE; //For use HIBYTE			now = (WORD)lpDIBFade->pOrgRGB[i].rgbGreen;			now <<= 1+lpDIBFade->iFadeBits; //Fade IN				mask <<= 1+lpDIBFade->iFadeBits;			now |= mask;			pRGB[i].rgbGreen = HIBYTE( now );						mask = (WORD)lpDIBFade->rgbBackGround.rgbBlue;			mask <<= MAX_FADE; //For use HIBYTE			now = (WORD)lpDIBFade->pOrgRGB[i].rgbBlue;			now <<= 1+lpDIBFade->iFadeBits; //Fade IN				mask <<= 1+lpDIBFade->iFadeBits;			now |= mask;			pRGB[i].rgbBlue = HIBYTE( now );				}		else{			mask = (WORD)lpDIBFade->rgbBackGround.rgbRed;			mask <<= MAX_FADE; //For use HIBYTE			now = (WORD)lpDIBFade->pOrgRGB[i].rgbRed;			now >>= 1+lpDIBFade->iFadeBits; //Fade OUT			mask >>= 1+lpDIBFade->iFadeBits;			now |= mask;			pRGB[i].rgbRed = LOBYTE( now );						mask = (WORD)lpDIBFade->rgbBackGround.rgbGreen;			mask <<= MAX_FADE; //For use HIBYTE			now = (WORD)lpDIBFade->pOrgRGB[i].rgbGreen;			now >>= 1+lpDIBFade->iFadeBits; //Fade OUT				mask >>= 1+lpDIBFade->iFadeBits;			now |= mask;			pRGB[i].rgbGreen = LOBYTE( now );						mask = (WORD)lpDIBFade->rgbBackGround.rgbBlue;			mask <<= MAX_FADE; //For use HIBYTE			now = (WORD)lpDIBFade->pOrgRGB[i].rgbBlue;			now >>= 1+lpDIBFade->iFadeBits; //Fade OUT				mask >>= 1+lpDIBFade->iFadeBits;			now |= mask;			pRGB[i].rgbBlue = LOBYTE( now );		}	}			GlobalUnlock( lpDIBFade->hDIB );	lpDIBFade->iFadeBits++;		if( lpDIBFade->iFadeBits >= MAX_FADE ){		lpDIBFade->iFadeBits = 0;		if( lpDIBFade->bIsFadeIn ){			lpDIBFade->bIsFadeIn = FALSE;			lpDIBFade->bIsFadeOut = TRUE;			return FADE_INEND;		}		else{			lpDIBFade->bIsFadeOut = FALSE;			//return FADE_OUTEND;	V2.00変更分--FADE_OUTEND をFADE_RUNNINGへ			return FADE_RUNNING;	//FADE_OUTENDは先頭で返す		}		}	return FADE_RUNNING;}VOID BeginTextFade( LPTEXTFADE lpTextFade ){	//指定色に変える	CopyMemory( &lpTextFade->rgbNow,&lpTextFade->rgbBackGround,sizeof(RGBQUAD) );	lpTextFade->iFadeBits = 0;	lpTextFade->bIsFadeIn = TRUE;	lpTextFade->bIsFadeOut = FALSE;}FADESTATUS FadeTextFade( LPTEXTFADE lpTextFade ){	WORD mask=0;	WORD now=0;	if( !lpTextFade->bIsFadeIn && !lpTextFade->bIsFadeOut )		return FADE_OUTEND;			if( lpTextFade->bIsFadeIn ){						mask = (WORD)lpTextFade->rgbBackGround.rgbRed;			mask <<= MAX_FADE; //For use HIBYTE			now = (WORD)lpTextFade->rgbOrg.rgbRed;			now <<= 1+lpTextFade->iFadeBits; //Fade IN				mask <<= 1+lpTextFade->iFadeBits;			now |= mask;			lpTextFade->rgbNow.rgbRed = HIBYTE( now );						mask = (WORD)lpTextFade->rgbBackGround.rgbGreen;			mask <<= MAX_FADE; //For use HIBYTE			now = (WORD)lpTextFade->rgbOrg.rgbGreen;			now <<= 1+lpTextFade->iFadeBits; //Fade IN				mask <<= 1+lpTextFade->iFadeBits;			now |= mask;			lpTextFade->rgbNow.rgbGreen = HIBYTE( now );						mask = (WORD)lpTextFade->rgbBackGround.rgbBlue;			mask <<= MAX_FADE; //For use HIBYTE			now = (WORD)lpTextFade->rgbOrg.rgbBlue;			now <<= 1+lpTextFade->iFadeBits; //Fade IN				mask <<= 1+lpTextFade->iFadeBits;			now |= mask;			lpTextFade->rgbNow.rgbBlue = HIBYTE( now );				}		else{			mask = (WORD)lpTextFade->rgbBackGround.rgbRed;			mask <<= MAX_FADE; //For use HIBYTE			now = (WORD)lpTextFade->rgbOrg.rgbRed;			now >>= 1+lpTextFade->iFadeBits; //Fade OUT			mask >>= 1+lpTextFade->iFadeBits;			now |= mask;			lpTextFade->rgbNow.rgbRed = LOBYTE( now );						mask = (WORD)lpTextFade->rgbBackGround.rgbGreen;			mask <<= MAX_FADE; //For use HIBYTE			now = (WORD)lpTextFade->rgbOrg.rgbGreen;			now >>= 1+lpTextFade->iFadeBits; //Fade OUT				mask >>= 1+lpTextFade->iFadeBits;			now |= mask;			lpTextFade->rgbNow.rgbGreen = LOBYTE( now );						mask = (WORD)lpTextFade->rgbBackGround.rgbBlue;			mask <<= MAX_FADE; //For use HIBYTE			now = (WORD)lpTextFade->rgbOrg.rgbBlue;			now >>= 1+lpTextFade->iFadeBits; //Fade OUT				mask >>= 1+lpTextFade->iFadeBits;			now |= mask;			lpTextFade->rgbNow.rgbBlue = LOBYTE( now );		}	lpTextFade->iFadeBits++;		if( lpTextFade->iFadeBits >= MAX_FADE ){		lpTextFade->iFadeBits = 0;		if( lpTextFade->bIsFadeIn ){			lpTextFade->bIsFadeIn = FALSE;			lpTextFade->bIsFadeOut = TRUE;			return FADE_INEND;		}		else{			lpTextFade->bIsFadeOut = FALSE;			//return FADE_OUTEND;	V2.00変更分--FADE_OUTEND をFADE_RUNNINGへ			return FADE_RUNNING;	//FADE_OUTENDは先頭で返す		}		}	return FADE_RUNNING;	}