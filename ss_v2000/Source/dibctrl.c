#include "dibctrl.h"#define BFT_BITMAP 0x4d42   /* 'BM' */#define PALVERSION      0x300#define MAXPALETTE      256       /* max. # supported palette entries *//* 4バイトパディング幅の計算 */#define WIDTHBYTES(i)   ((i+31)/32*4)static HPALETTE CreateBIPalette (const LPBITMAPINFOHEADER lpbi);static ERRCODE ReadHeaderAndColorTable(const HANDLE fh,LPHANDLE lphBi);static VOID ReadFileHeader(const HANDLE fh, LPBITMAPFILEHEADER pbf, LPDWORD lpdwoff);/**************************************************************************** *                                                                          * *  FUNCTION   :OpenDIB(LPSTR szFile)                                       * *                                                                          * *  PURPOSE    :Open a DIB file and create a MEMORY DIB, a memory handle    * *              containing BITMAPINFO, palette data and the bits.           * *                                                                          * *  RETURNS    :A handle to the DIB.                                        * *                                                                          * ****************************************************************************/ERRCODE OpenDIB ( LPCTSTR szFile,LPHANDLE lphDIB ){    HANDLE               fh;    BITMAPINFOHEADER    bi;    LPBITMAPINFOHEADER  lpbi;    DWORD               dwLen = 0;    DWORD               dwBits;    DWORD		  dwBytesRead;    HANDLE              hdib;    HANDLE              h;    ERRCODE err = ERR_NOTHING;    //初期化	*lphDIB = NULL;    /* Open the file and read the DIB information */    fh = CreateFile(szFile,			GENERIC_READ,			FILE_SHARE_READ,			NULL,			OPEN_EXISTING,			FILE_ATTRIBUTE_NORMAL,			(HANDLE)NULL );        if (fh == (HANDLE)-1)        return ERR_FILEACCESS;    err = ReadHeaderAndColorTable(fh,&hdib);    if (err!=ERR_NOTHING)        return err;        bi = *(LPBITMAPINFOHEADER)GlobalLock (hdib);    GlobalUnlock (hdib);        /* Calculate the memory needed to hold the DIB */    dwBits = bi.biSizeImage;    dwLen  = bi.biSize + (DWORD)PaletteSize (&bi) + dwBits;    /* Try to increase the size of the bitmap info. buffer to hold the DIB */    h = GlobalReAlloc(hdib, dwLen, GHND);    if (!h){        GlobalFree(hdib);        hdib = NULL;    	 err = ERR_MEMORY;    }    else        hdib = h;    /* ビットデータ部一気読み */    if (hdib){        lpbi = (VOID FAR *)GlobalLock(hdib);        ReadFile(fh, (LPSTR)lpbi + (WORD)lpbi->biSize + PaletteSize(lpbi), dwBits,&dwBytesRead,NULL);        GlobalUnlock(hdib);      }     CloseHandle(fh);    *lphDIB = hdib;    return err;}/**************************************************************************** *                                                                          * *  FUNCTION   : CreateBIPalette(LPBITMAPINFOHEADER lpbi)                   * *                                                                          * *  PURPOSE    : Given a Pointer to a BITMAPINFO struct will create a       * *               a GDI palette object from the color table.                 * *                                                                          * *  RETURNS    : A handle to the palette.                                   * *                                                                          * ****************************************************************************/HPALETTE CreateBIPalette (const LPBITMAPINFOHEADER lpbi){    LOGPALETTE          *pPal;    HPALETTE            hpal = NULL;    WORD                nNumColors;    BYTE                red;    BYTE                green;    BYTE                blue;    WORD                i;    RGBQUAD        FAR *pRgb;    if (!lpbi)        return NULL;    if (lpbi->biSize != sizeof(BITMAPINFOHEADER))        return NULL;    /* Get a pointer to the color table and the number of colors in it */    pRgb = (RGBQUAD FAR *)((LPSTR)lpbi + (WORD)lpbi->biSize);    nNumColors = lpbi->biClrUsed;    if (nNumColors){        /* Allocate for the logical palette structure */        pPal = (LOGPALETTE*)LocalAlloc(LPTR,sizeof(LOGPALETTE) + nNumColors * sizeof(PALETTEENTRY));        if (!pPal)            return NULL;        pPal->palNumEntries = nNumColors;        pPal->palVersion    = PALVERSION;        /* Fill in the palette entries from the DIB color table and         * create a logical color palette.         */        for (i = 0; i < nNumColors; i++){            pPal->palPalEntry[i].peRed   = pRgb[i].rgbRed;            pPal->palPalEntry[i].peGreen = pRgb[i].rgbGreen;            pPal->palPalEntry[i].peBlue  = pRgb[i].rgbBlue;            pPal->palPalEntry[i].peFlags = (BYTE)0;        }        hpal = CreatePalette(pPal);        LocalFree((HANDLE)pPal);    }    else if (lpbi->biBitCount == 24){        /* A 24 bitcount DIB has no color table entries so, set the number of         * to the maximum value (256).         */        nNumColors = MAXPALETTE;        pPal = (LOGPALETTE*)LocalAlloc(LPTR,sizeof(LOGPALETTE) + nNumColors * sizeof(PALETTEENTRY));        if (!pPal)            return NULL;        pPal->palNumEntries = nNumColors;        pPal->palVersion    = PALVERSION;        red = green = blue = 0;        /* Generate 256 (= 8*8*4) RGB combinations to fill the palette         * entries.         */        for (i = 0; i < pPal->palNumEntries; i++){            pPal->palPalEntry[i].peRed   = red;            pPal->palPalEntry[i].peGreen = green;            pPal->palPalEntry[i].peBlue  = blue;            pPal->palPalEntry[i].peFlags = (BYTE)0;            if (!(red += 32))                if (!(green += 32))                    blue += 64;        }        hpal = CreatePalette(pPal);        LocalFree((HANDLE)pPal);    }    return hpal;}/**************************************************************************** *                                                                          * *  FUNCTION   : CreateDibPalette(HANDLE hbi)                               * *                                                                          * *  PURPOSE    : Given a Global HANDLE to a BITMAPINFO Struct               * *               will create a GDI palette object from the color table.     * *               (BITMAPINFOHEADER format DIBs only)                                     * *                                                                          * *  RETURNS    : A handle to the palette.                                   * *                                                                          * ****************************************************************************/HPALETTE CreateDibPalette (const HANDLE hbi){    HPALETTE hpal;    if (!hbi)        return NULL;    hpal = CreateBIPalette((LPBITMAPINFOHEADER)GlobalLock(hbi));    GlobalUnlock(hbi);    return hpal;}/**************************************************************************** *                                                                          * *  FUNCTION   : ReadDibBitmapInfo(int fh)                                  * *                                                                          * *  PURPOSE    : Will read a file in DIB format and return a global HANDLE  * *               to it's BITMAPINFO.  This function will work with both     * *               "old" (BITMAPCOREHEADER) and "new" (BITMAPINFOHEADER)      * *               bitmap formats, but will always return a "new" BITMAPINFO  * *                                                                          * *  RETURNS    : A handle to the BITMAPINFO of the DIB in the file.         * *                                                                          * ****************************************************************************///BITMAPINFOHEADERとRGBQUAD配列を作成する//古い形式のDIBも変換されるERRCODE ReadHeaderAndColorTable(const HANDLE fh,LPHANDLE lphBi){    DWORD     off;    HANDLE    hbi = NULL;    INT       size;    INT       i;    WORD      nNumColors;    INT                 bits;    RGBQUAD FAR       *pRgb;    BITMAPINFOHEADER   bi;    BITMAPCOREHEADER   bc;    LPBITMAPINFOHEADER lpbi;    BITMAPFILEHEADER   bf;    DWORD              dwWidth = 0;    DWORD              dwHeight = 0;    DWORD		dwBytesRead;    WORD               wPlanes, wBitCount;    //初期化    *lphBi = NULL;    ReadFileHeader(fh, &bf, &off);           /* Do we have a RC HEADER? */    if ((bf.bfType) != BFT_BITMAP) {            bf.bfOffBits = 0L;                               SetFilePointer(fh, off,NULL,FILE_BEGIN); /*seek back to beginning of file*/    }    ReadFile( fh,(LPVOID)&bi,(DWORD)sizeof(bi),&dwBytesRead,NULL );       if (dwBytesRead != sizeof (bi))        return ERR_FILEACCESS;   /*ビット数からカラー数を計算する */     if (bi.biSize != sizeof(BITMAPCOREHEADER)){        if (bi.biClrUsed != 0)            nNumColors = (WORD)bi.biClrUsed;        bits = bi.biBitCount;    }    else{        bc = *(BITMAPCOREHEADER*)&bi;        bits = bc.bcBitCount;    }    switch (bits){        case 1:                nNumColors = 2;     	 break;        case 4:                nNumColors = 16;        break;        case 8:                nNumColors = 256;        break;        default:                /* 24bitカラー */                nNumColors = 0;    	 break;    }        //古い形式のチェックとコンバート    switch (size = (INT)bi.biSize){        case sizeof (BITMAPINFOHEADER):            break;                    case sizeof (BITMAPCOREHEADER):            dwWidth   = (DWORD)bc.bcWidth;            dwHeight  = (DWORD)bc.bcHeight;            wPlanes   = bc.bcPlanes;            wBitCount = bc.bcBitCount;            bi.biSize           = sizeof(BITMAPINFOHEADER);            bi.biWidth              = dwWidth;            bi.biHeight             = dwHeight;            bi.biPlanes             = wPlanes;            bi.biBitCount           = wBitCount;            bi.biCompression        = BI_RGB;            bi.biSizeImage          = 0;            bi.biXPelsPerMeter      = 0;            bi.biYPelsPerMeter      = 0;            bi.biClrUsed            = nNumColors;            bi.biClrImportant       = nNumColors;            //COREHEADERはINFOHEADERより小さいので、読み過ぎを戻す            SetFilePointer(fh,             	(LONG)sizeof (BITMAPCOREHEADER) - sizeof (BITMAPINFOHEADER), NULL,FILE_CURRENT);            break;        default:            /* どちらにも当てはまらない場合、DIBファイルではない */            return ERR_FILEFORMAT;    }    /*  セットされていない値の計算 */    if (bi.biSizeImage == 0){        bi.biSizeImage = WIDTHBYTES ((DWORD)bi.biWidth * bi.biBitCount)                         * bi.biHeight;    }    if (bi.biClrUsed == 0)        bi.biClrUsed = nNumColors;    /* BITMAPINFOとカラーテーブルを格納する領域を作成 */    hbi = GlobalAlloc (GHND, (LONG)bi.biSize + nNumColors * sizeof(RGBQUAD));    if (!hbi)        return ERR_MEMORY;    lpbi = (VOID FAR *)GlobalLock (hbi);    *lpbi = bi; //BITMAPINFOHEADER格納    /* カラーテーブルの格納 */    pRgb = (RGBQUAD FAR *)((LPSTR)lpbi + bi.biSize);    if (nNumColors){        if (size == sizeof(BITMAPCOREHEADER)){            /* 古い形式のカラーテーブルを変換する */            ReadFile(fh, (LPVOID)pRgb, (DWORD)nNumColors * sizeof(RGBTRIPLE),&dwBytesRead,NULL);            for (i = nNumColors - 1; i >= 0; i--){                RGBQUAD rgb;                rgb.rgbRed      = ((RGBTRIPLE FAR *)pRgb)[i].rgbtRed;                rgb.rgbBlue     = ((RGBTRIPLE FAR *)pRgb)[i].rgbtBlue;                rgb.rgbGreen    = ((RGBTRIPLE FAR *)pRgb)[i].rgbtGreen;                rgb.rgbReserved = (BYTE)0;                pRgb[i] = rgb;            }        }        else /* 新しい形式は変換の必要なし */            ReadFile(fh, (LPVOID)pRgb, (DWORD)nNumColors * sizeof(RGBQUAD),&dwBytesRead,NULL);    }    if (bf.bfOffBits != 0L){        SetFilePointer(fh, off + bf.bfOffBits,NULL, FILE_BEGIN);        }    GlobalUnlock(hbi);    *lphBi = hbi;    return ERR_NOTHING;}WORD PaletteSize (const LPBITMAPINFOHEADER lpbi){		 return (WORD)(lpbi->biClrUsed * sizeof(RGBQUAD));}//ファイルヘッダ部の読み込みVOID ReadFileHeader(const HANDLE fh, LPBITMAPFILEHEADER pbf, LPDWORD lpdwoff){        DWORD off,dwBytesRead;        off = SetFilePointer(fh, 0L,NULL,FILE_CURRENT);        *lpdwoff = off;/*              BITMAPFILEHEADER STRUCUTURE is as follows  *              BITMAPFILEHEADER *              WORD    bfType  >          ....                  <     add WORD if packed here! *              DWORD   bfSize  *              WORD    bfReserved1 *              WORD    bfReserved2 *              DWORD   bfOffBits  *                      This is the packed format, unpacked adds a WORD after bfType */         /* read in bfType*/        ReadFile(fh, (LPVOID) &pbf->bfType, sizeof(WORD),&dwBytesRead,NULL);            /* read in last 3 dwords*/        ReadFile(fh, (LPVOID) &pbf->bfSize, sizeof(DWORD) * 3,&dwBytesRead,NULL);        }/**************************************************************************** *                                                                          * *  FUNCTION   : BitmapFromDib(HANDLE hdib, HPALETTE hpal)                  * *                                                                          * *  PURPOSE    : Will create a DDB (Device Dependent Bitmap) given a global * *               handle to a memory block in CF_DIB format                  * *                                                                          * *  RETURNS    : A handle to the DDB.                                       * *                                                                          * ****************************************************************************/HBITMAP BitmapFromDib (    const HANDLE         hdib,    const HPALETTE   hpal){    LPBITMAPINFOHEADER  lpbi;    HPALETTE            hpalT;    HDC                 hdc;    HBITMAP             hbm;    if (!hdib)        return NULL;    lpbi = (VOID FAR *)GlobalLock(hdib);    if (!lpbi)        return NULL;    hdc = GetDC(NULL);    if (hpal){        hpalT = SelectPalette(hdc,hpal,FALSE);        RealizePalette(hdc);     // GDI Bug...????    }    hbm = CreateDIBitmap(hdc,                (LPBITMAPINFOHEADER)lpbi,                (LONG)CBM_INIT,                (LPSTR)lpbi + lpbi->biSize + PaletteSize(lpbi),                (LPBITMAPINFO)lpbi,                DIB_RGB_COLORS );    if (hpal)        SelectPalette(hdc,hpalT,FALSE);    ReleaseDC(NULL,hdc);    GlobalUnlock(hdib);    return hbm;}/**************************************************************************** *                                                                          * *  FUNCTION   : DrawBitmap(HDC hdc, int x, int y, HBITMAP hbm, DWORD rop)  * *                                                                          * *  PURPOSE    : Draws bitmap <hbm> at the specifed position in DC <hdc>    * *                                                                          * *  RETURNS    : Return value of BitBlt()                                   * *                                                                          * ****************************************************************************/BOOL DrawBitmap (    HDC    hdc,    INT    x,    INT    y,    const HBITMAP    hbm,    DWORD          rop){    HDC       hdcBits;    BITMAP    bm;//    HPALETTE  hpalT;      BOOL      f;    if (!hdc || !hbm)        return FALSE;    hdcBits = CreateCompatibleDC(hdc);    GetObject(hbm,sizeof(BITMAP),(LPSTR)&bm);    SelectObject(hdcBits,hbm);    f = BitBlt(hdc,0,0,bm.bmWidth,bm.bmHeight,hdcBits,0,0,rop);    DeleteDC(hdcBits);    return f;        UNREFERENCED_PARAMETER(y);        UNREFERENCED_PARAMETER(x);}/**************************************************************************** *                                                                          * *  FUNCTION   : DibBlt( HDC hdc,                                           * *                       int x0, int y0,                                    * *                       int dx, int dy,                                    * *                       HANDLE hdib,                                       * *                       int x1, int y1,                                    * *                       LONG rop)                                          * *                                                                          * *  PURPOSE    : Draws a bitmap in CF_DIB format, using SetDIBits to device.* *               taking the same parameters as BitBlt().                    * *                                                                          * *  RETURNS    : TRUE  - if function succeeds.                              * *               FALSE - otherwise.                                         * *                                                                          * ****************************************************************************/BOOL DibBlt (    HDC    hdc,    INT    x0,    INT    y0,    INT    dx,    INT    dy,    const HANDLE hdib,    INT    x1,    INT    y1,    LONG   rop){    LPBITMAPINFOHEADER   lpbi;//    HPALETTE           hpal,hpalT;    LPSTR                pBuf;//    HDC                hdcMem;//    HBITMAP            hbm,hbmT;    if (!hdib)        return PatBlt(hdc,x0,y0,dx,dy,rop);    lpbi = (VOID FAR *)GlobalLock(hdib);    if (!lpbi)        return FALSE;    pBuf = (LPSTR)lpbi + (WORD)lpbi->biSize + PaletteSize(lpbi);    SetDIBitsToDevice (hdc, x0, y0, dx, dy,                       x1,y1,                       x1,                       dy,                       pBuf, (LPBITMAPINFO)lpbi,                       DIB_RGB_COLORS );    GlobalUnlock(hdib);    return TRUE;}/**************************************************************************** *                                                                          * *  FUNCTION   : StretchDibBlt( HDC hdc,                                    * *                              int x, int y,                               * *                              int dx, int dy,                             * *                              HANDLE hdib,                                * *                              int x0, int y0,                             * *                              int dx0, int dy0,                           * *                              LONG rop)                                   * *                                                                          * *  PURPOSE    : Draws a bitmap in CF_DIB format, using StretchDIBits()     * *               taking the same parameters as StretchBlt().                * *                                                                          * *  RETURNS    : TRUE  - if function succeeds.                              * *               FALSE - otherwise.                                         * *                                                                          * ****************************************************************************/BOOL StretchDibBlt (    HDC hdc,    INT x,    INT y,    INT dx,    INT dy,    const HANDLE hdib,    INT x0,    INT y0,    INT dx0,    INT dy0,    LONG rop){    LPBITMAPINFOHEADER lpbi;    LPSTR        pBuf;    BOOL         f;    if (!hdib)        return PatBlt(hdc,x,y,dx,dy,rop);    lpbi = (VOID FAR *)GlobalLock(hdib);    if (!lpbi)        return FALSE;    pBuf = (LPSTR)lpbi + (WORD)lpbi->biSize + PaletteSize(lpbi);    f = StretchDIBits ( hdc,                        x, y,                        dx, dy,                        x0, y0,                        dx0, dy0,                        pBuf, (LPBITMAPINFO)lpbi,                        DIB_RGB_COLORS,                        rop);    GlobalUnlock(hdib);    return f;}