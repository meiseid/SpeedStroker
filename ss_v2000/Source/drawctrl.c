#include "drawctrl.h"#include "mondai.h"#include "timectrl.h"#include "modeb.h"#include "moded.h"#include "modee.h"#include "appdata.h"#include "modea.h"#include "modec.h"#include "modef.h"#include "modeg.h"#include "char.h"extern HWND g_hWnd;static BOOL g_bIsEndOfDraw=FALSE;static BOOL g_bLastStatusOut=FALSE;static INT g_timecount;static RECT g_rCount;static RECT g_rProg;static RECT g_rMax;static INT g_iScreen=-1; //現在のスクリーンstatic HFONT g_hFontOld; //Working//ストローク画面static VOID DrawStroke( HDC hDC );//ステータス画面static VOID DrawStatus( HDC hDC );BOOL IsEndOfDraw( VOID ){	return g_bIsEndOfDraw;}INT GetCurrentScreen( VOID ){	return g_iScreen;}VOID SwitchScreen( INT iScreen,BOOL bErase ){	HDC hDC;		if( g_iScreen == SS_MODED ){		CHAR buff[256];				lstrcpy( buff,"Progress: " );		CopyRect( &g_rProg,GetRectangle( GR_PROGRESS ) );		AdjustRect( g_hWnd,GetFont(GF_SUMMANY_GUIDE),&g_rProg,buff,AR_LEFT);				wsprintf( buff,"%ld",GetSSTA()->dwMax );		CopyRect( &g_rCount,GetRectangle( GR_PROGRESS ) );		g_rCount.left = g_rProg.right+1;		AdjustRect( g_hWnd,GetFont(GF_SUMMANY_GUIDE),&g_rCount,buff,AR_LEFT);				wsprintf( buff," / %ld",GetSSTA()->dwMax );		CopyRect( &g_rMax,GetRectangle( GR_PROGRESS ) );		g_rMax.left = g_rCount.right+1;		AdjustRect( g_hWnd,GetFont(GF_SUMMANY_GUIDE),&g_rMax,buff,AR_LEFT);						InvalidateRect( g_hWnd,GetRectangle(GR_STROKE_GUIDE),FALSE );			InvalidateRect( g_hWnd,GetRectangle(GR_PROGRESS),FALSE );		}	if( g_iScreen != -1 ){		g_bIsEndOfDraw = FALSE;		//以前のスクリーンを消す		if( bErase ){			ERASERECT( GetRectangle(g_iScreen) );					}	}		g_iScreen = iScreen;	//描く	switch( g_iScreen ){		case SS_STROKE:		InvalidateRect( g_hWnd,GetRectangle(GR_STROKE),TRUE );			InvalidateRect( g_hWnd,&g_rCount,TRUE ); //カウントのみ書き換え			//2文字につき1秒の時間を与える	  	StartTimerEx( ST_STROKE,GetMondaiValiable(GMV_TIMEOVEROK));		break;		case SS_STATUS:		InvalidateRect( g_hWnd,GetRectangle(GR_STATUS),TRUE );		StartTimer( ST_STATUS );	break;		//フェードイン/アウト	case SS_MODEB:		StartTimer( ST_MODEB );	break;		case SS_MODED:		StartTimer( ST_MODED );	break;		case SS_MODEA:		StartTimer( ST_MODEA );	break;		case SS_MODEC:		StartTimer( ST_MODEC );	break;		case SS_MODEE:		StartTimer( ST_MODEE );	break;		case SS_MODEF:		StartTimer( ST_MODEF );	break;		case SS_MODEG:		StartTimer( ST_MODEG );	break;		default:		break;		}}//描画VOID DrawScreen( HDC hDC ){	                  //Guide is Constant Draw       if( GetCurrentScreen() == SS_STROKE || GetCurrentScreen() == SS_STATUS ){        	CHAR buff[256];               	SELECTFONT( GetFont(GF_SUMMANY_GUIDE) );        	        	COLORTEXT( 0xFF,0x00,0x00 );  		DRAWTEXTRIGHT( GetString( GS_STROKE_GUIDE ),GetRectangle(GR_STROKE_GUIDE) );  		  		DRAWTEXTLEFT( "Progress: ",&g_rProg );  		if( GetSSTA()->iNext != (-1) )  			wsprintf( buff,"%ld",GetSSTA()->iNext );  		else  			wsprintf( buff,"%ld",GetSSTA()->dwMax );  		DRAWTEXTRIGHT( buff,&g_rCount );  		wsprintf( buff," / %ld",GetSSTA()->dwMax );  		DRAWTEXTLEFT( buff,&g_rMax );  		        	RESTOREFONT();        }		if( g_bLastStatusOut ){		DrawStatus(hDC);		g_bLastStatusOut = FALSE;		return;	}		switch( GetCurrentScreen() ){		     	case SS_STROKE:        	DrawStroke(hDC);		break;				case SS_STATUS:			DrawStatus(hDC);		break;				case SS_MODEB:			DrawModeB(hDC);		break;				case SS_MODED:			DrawModeD( hDC );		break;				case SS_MODEA:			DrawModeA( hDC );		break;				case SS_MODEC:			DrawModeC( hDC );		break;				case SS_MODEE:			DrawModeE( hDC );		break;				case SS_MODEF:			DrawModeF( hDC );		break;				case SS_MODEG:			DrawModeG( hDC );		break;				default:		break;	}}//// ストローク画面//VOID DrawStroke( HDC hDC ){	//問題文領域出力		SELECTFONT( GetFont(GF_STROKE_STATIC) );		COLORTEXT( 0xFF,0xFF,0xFF );		DRAWTEXTCENTER( GetStrokeString( GSS_STATIC ),GetRectangle(GR_STROKE_STATIC) );           	RESTOREFONT();	                   //タイピング領域出力            SELECTFONT( GetFont(GF_STROKE_INPUT) );            COLORTEXT( 0xFF,0xFF,0xFF );  		DRAWTEXTCENTER( GetStrokeString( GSS_INPUT ),GetRectangle(GR_STROKE_INPUT) );            RESTOREFONT();            }//// ステータス画面//VOID DrawStatus( HDC hDC ){		//ステータス領域出力           SELECTFONT( GetFont(GF_STATUS) );                  switch( GetMondaiValiable(GMV_STATUS) ){            	case STATUS_GOOD:            	COLORTEXT( 0x00,0xFF,0xFF );            	DRAWTEXTCENTER( GetString( GS_STATUS_GOOD ),GetRectangle(GR_STATUS) );           		break;           		case STATUS_MISS:           		COLORTEXT( 0xFF,0xFF,0x00 );            	DRAWTEXTCENTER( GetString( GS_STATUS_MISS ),GetRectangle(GR_STATUS) );           		break;           		case STATUS_TIMEOVER:           		COLORTEXT( 0x00,0xFF,0x00 );            	DRAWTEXTCENTER( GetString( GS_STATUS_TIMEOVER ),GetRectangle(GR_STATUS) );            	break;	           	           		case STATUS_GIVEUP:           		COLORTEXT( 0x77,0x55,0xFF );            	DRAWTEXTCENTER( GetString( GS_STATUS_GIVEUP ),GetRectangle(GR_STATUS) );            	break;	           	           	}           				RESTOREFONT();}