#include "gamectrl.h"#include "mondai.h"#include "drawctrl.h"#include "timectrl.h"#include "modeb.h"#include "moded.h"#include "modea.h"#include "modec.h"#include "modee.h"#include "modef.h"#include "modeg.h"extern HWND g_hWnd;//ゲームスタートVOID StartGame( BOOL bErase ){   	StartModeD( bErase );}//ゲーム終了VOID EndGame( VOID ){	HDC hDC; 	EndMondaiData();	ERASERECT( GetRectangle(GR_STROKE_GUIDE) ); /*ガイドを消す*/	ERASERECT( GetRectangle(GR_PROGRESS) );	StartTimerEx( ST_DELAY,2000 ); //一秒待つ}//For WndProc//For WM_TIMERVOID TimerGame( UINT timerID ){	switch ( timerID ){			//ステータスメッセージ表示終了		case ST_STATUS:			EndTimer();			SwitchScreen( SS_STROKE,TRUE );		break;				//タイムオーバー		case ST_STROKE:			EndTimer();						SwitchScreen( SS_STATUS,TRUE );        	        	if( TimeOverMondai() == MM_MONDAIDATAEND )        		EndGame();		break;				case ST_MODEB:			if( !ProcessModeB() ){				switch( GetModeBSelection( ) ){					case 0:						StartModeC( FALSE );					break;									case 1:						StartModeE( FALSE );					break;										case 2:						StartModeG( FALSE );					break;										case 3:						DestroyWindow( g_hWnd );					break;								}			}				break;				case ST_MODED:			if( !ProcessModeD() ){				StartMondaiData();					SwitchScreen( SS_STROKE,TRUE );			}		break;				case ST_MODEA:			if( !ProcessModeA() )				StartModeB( FALSE );		break;		case ST_MODEC:			if( !ProcessModeC() ){				if( GetModeCSelection() )					StartGame( FALSE );				else					StartModeB( FALSE );			}				break;				case ST_MODEE:			if( !ProcessModeE() )				StartModeB( FALSE );		break;				case ST_MODEF:			if( !ProcessModeF() )				StartModeC( FALSE );		break;				case ST_MODEG:			if( !ProcessModeG() )				StartModeB( FALSE );		break;				case ST_DELAY:			EndTimer();			StartModeF( FALSE/*TRUE*/ );		break;		default:				break;		}}//For WM_CHAR//キャラクタコードの入力に反応するVOID CharGame( BYTE code ){	UINT status;	BOOL ret;	if( GetCurrentScreen()==SS_MODEF ){		CharModeF( code );		return;	}	if( GetCurrentScreen()!=SS_STROKE )		return;	ret = ModifyMondai( code,&status );		if( ret ){        if( status == MM_MONDAIEND || status == MM_MONDAIDATAEND ){        	SwitchScreen( SS_STATUS,TRUE );        	if( status == MM_MONDAIDATAEND )        		EndGame();		}		else{			InvalidateRect( g_hWnd,GetRectangle(GR_STROKE_INPUT),TRUE );		}        	}	else{        if( status == MM_MONDAIEND || status == MM_MONDAIDATAEND ){        	SwitchScreen( SS_STATUS,TRUE );        	if( status == MM_MONDAIDATAEND )        		EndGame();        }    	}}//For WM_KEYDOWNVOID KeyGame( UINT key ){	//ESCだけはちと特別	if( key == VK_ESCAPE ){		if( GetCurrentScreen()==SS_STROKE ){			GiveUpMondai();			SwitchScreen( SS_STATUS,TRUE );			EndGame();		}		else{			FreeModeE(); //例外メモリ			DestroyWindow( g_hWnd );		}		return;	}	switch( GetCurrentScreen() ){		case SS_MODEB:		KeyModeB( key );	break;		case SS_MODEC:		KeyModeC( key );	break;		case SS_MODEE:		KeyModeE( key );	break;		case SS_MODEF:		KeyModeF( key );	break;		case SS_MODEG:		KeyModeG( key );	break;		default:	break;		}}//For WM_LBUTTONDOWNVOID ClickGame( WORD x,WORD y ){	switch( GetCurrentScreen() ){		case SS_MODEB:		ClickModeB( x,y );	break;		case SS_MODEC:		ClickModeC( x,y );	break;		case SS_MODEE:		ClickModeE( x,y );	break;		case SS_MODEF:		ClickModeF( x,y );	break;		case SS_MODEG:		ClickModeG( x,y );	break;		default:	break;		}	}//For WM_MOUSEMOVEVOID CursorGame( WORD x,WORD y ){	switch( GetCurrentScreen() ){	case SS_MODEB:		CursorModeB( x,y );	break;		case SS_MODEC:		CursorModeC( x,y );	break;		case SS_MODEE:		CursorModeE( x,y );	break;		case SS_MODEF:		CursorModeF( x,y );	break;		case SS_MODEG:		CursorModeG( x,y );	break;		default:	break;		}	}